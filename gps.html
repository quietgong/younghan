<!DOCTYPE html>
<html lang="ko">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>실시간 위치 정보</title>
  <script src="https://cdn.jsdelivr.net/npm/axios@1.7.7/dist/axios.min.js"></script>
  <!-- Google Maps API -->
  <script async defer
    src="https://maps.googleapis.com/maps/api/js?key=AIzaSyBr4PpRcc8az-paeV336EDFLpFgkB2FQxQ"></script>
  <style>
    /* html과 body에 기본 여백 제거 */
    html,
    body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      /* 스크롤바가 나타나지 않도록 설정 */
    }

    #map {
      height: 100vh;
      width: 100vw;
    }

    /* 버튼을 화면 하단 중앙에 배치 */
    .center-button {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      padding: 10px 20px;
      background-color: #ff6600;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }

    .custom-marker {
      width: 50px;
      height: 50px;
      background-image: url('arrow.png');
      /* 원하는 이미지 사용 */
      background-size: cover;
      position: absolute;
      transform-origin: center;
    }
  </style>
</head>

<body>
  <div id="map">지도 로드 중...</div>
  <button class="center-button" onclick="location.href=`https://plinqer.8thwall.app/proximity`">GO TO AR MODE</button>

  <script>
    let userName;
    let lastLatitude = null;
    let lastLongitude = null;
    let lastAlpha = null;
    let map, marker;

    const trackingInterval = 3000;

    function getUserName() {
      userName = prompt("닉네임을 입력하세요");
    }

    function initMap(latitude, longitude) {
      const userPosition = { lat: latitude, lng: longitude };

      // 지도 초기화
      map = new google.maps.Map(document.getElementById("map"), {
        zoom: 16,
        center: userPosition,
      });

      // 커스텀 마커를 위한 HTML 요소 생성
      markerElement = document.createElement('div');
      markerElement.className = 'custom-marker';

      // 커스텀 오버레이 정의
      class CustomMarker extends google.maps.OverlayView {
        constructor(position) {
          super();
          this.position = position;
        }

        onAdd() {
          const panes = this.getPanes();
          panes.overlayLayer.appendChild(markerElement);
        }

        draw() {
          const projection = this.getProjection();
          const position = projection.fromLatLngToDivPixel(this.position);

          if (position) {
            markerElement.style.left = position.x + 'px';
            markerElement.style.top = position.y + 'px';
          }
        }

        onRemove() {
          markerElement.parentNode.removeChild(markerElement);
        }

        setPosition(position) {
          this.position = position;
          this.draw();
        }
      }

      // 커스텀 마커 오버레이 추가
      currentOverlay = new CustomMarker(userPosition);
      currentOverlay.setMap(map);
    }

    // 마커 회전 함수 (CSS transform 사용)
    function rotateMarker(angle) {
      if (angle !== lastAlpha){
        if (Math.abs(alpha - lastAlpha) > 180) {
          if (alpha > previousAlpha) {
            alpha -= 360;
          } else {
            alpha += 360;
          }
        }
        markerElement.style.transform = `rotate(${angle}deg)`;
      }
    }

    // 위치와 헤딩을 업데이트하는 함수
    function updatePosition(latitude, longitude, heading) {
      const newPosition = new google.maps.LatLng(latitude, longitude);
      currentOverlay.setPosition(newPosition);
      rotateMarker(heading); // 마커 회전
    }

    function startTracking() {
      setInterval(() => {
        navigator.geolocation.getCurrentPosition(currentPos, showError)
      }, trackingInterval);
    }

    // DeviceOrientationEvent에서 alpha 값을 비동기적으로 가져오는 함수
    async function getAlpha() {
      return new Promise((resolve) => {
        if (window.DeviceOrientationEvent) {
          // deviceorientation 이벤트가 발생할 때까지 기다림
          window.addEventListener('deviceorientation', (event) => {
            resolve(event.alpha); // 이벤트 발생 시 alpha 값 반환
          }, { once: true }); // 이벤트는 한 번만 처리하도록 설정
        } else {
          resolve(null); // DeviceOrientationEvent가 지원되지 않으면 null 반환
        }
      });
    }

    async function updatePosition(lat, lng) {
      if (lat !== lastLatitude || lng !== lastLongitude) {
        lastLatitude = lat;
        lastLongitude = lng;

        const newPosition = { lat: lat, lng: lng };
        currentOverlay.setPosition(newPosition);
        map.setCenter(newPosition);

        const data = {
          "userName": userName,
          "latitude": lat,
          "longitude": lng
        };

        await savePosition(data); // GPS 정보 서버로 전송
      }
    }

    async function currentPos(pos) {
      const currentLatitude = pos.coords.latitude;
      const currentLongitude = pos.coords.longitude;
      const currentAlpha = await getAlpha();

      rotateMarker(currentAlpha);
      updatePosition(currentLatitude, currentLongitude);
    }

    async function savePosition(data) {
      try {
        const res = await axios.post("http://115.20.193.140:8888/gps", data);
        console.log(res.data);
      } catch (error) {
        console.error(error);
      }
    }

    function showError(error) {
      switch (error.code) {
        case error.PERMISSION_DENIED:
          document.getElementById("location").innerHTML = "위치 정보 제공을 거부했습니다.";
          break;
        case error.POSITION_UNAVAILABLE:
          document.getElementById("location").innerHTML = "위치 정보를 사용할 수 없습니다.";
          break;
        case error.TIMEOUT:
          document.getElementById("location").innerHTML = "위치 정보 요청 시간이 초과되었습니다.";
          break;
        case error.UNKNOWN_ERROR:
          document.getElementById("location").innerHTML = "알 수 없는 오류가 발생했습니다.";
          break;
      }
    }

    getUserName(); // 닉네임 입력
    navigator.geolocation.getCurrentPosition(function (position) {
      initMap(position.coords.latitude, position.coords.longitude);
      startTracking();
    }, showError);
  </script>
</body>

</html>